#### 概述
&emsp;&emsp;调停者模式是对象的行为模式。调停者模式包装了一系列对象相互作用的方式，使得这些对象**不必相互明显引用**。从而使他们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。

#### 调停者的优点
##### 为什么需要调停者
&emsp;&emsp;如下图所示，存在多个对象，既能影响别的对象，也会被别的对象影响，被叫做(Colleague)对象。从图中复杂交错的关系网可以看出(一个对象与另一个对象的直接耦合)，这个系统耦合度很高。
![image](https://github.com/wooyeeyii/UsefulImage/blob/master/youdao/design%20pattern/mediator1.jpg?raw=true)
&emsp;&emsp;通过引入调停者(Mediator)，可以将系统的网状结构变为以中介者为中心的星形结构。而上图中一个对象对另一个对象的直接作用发生了变化，变为通过调停者对象与另一个对象发生相互作用。调停者对象的存在**保证了对象结构上的稳定**(系统的结构不会应为新对象的引入造成大量的修改工作)。
![image](https://github.com/wooyeeyii/UsefulImage/blob/master/youdao/design%20pattern/mediator2.jpg?raw=true)
##### 结合实例分析
&emsp;&emsp;如果电脑没有主板，则各个配件之间就必须自行相互交互，以互相传送数据。而且由于各个配件的接口不同，相互之间交互时，还必须把数据接口进行转换才能匹配上。
![image](https://github.com/wooyeeyii/UsefulImage/blob/master/youdao/design%20pattern/mediator3.jpg?raw=true)
&emsp;&emsp;有了主板，各个配件的交互完全通过主板来完成，每个配件都只需要和主板交互，而主板知道如何跟所有的配件打交道，这样就简单多了。(主板在这个例子中就充当了调停者对象的作用)
![image](https://github.com/wooyeeyii/UsefulImage/blob/master/youdao/design%20pattern/mediator4.jpg?raw=true)

#### 调停者模式的结构
- 抽象调停者(Mediator)角色：定义出同事对象到调停者对象的接口，其中主要方法时一个或多个事件方法；
- 具体调停者(ConcreteMediator)角色：实现了抽象调停者所声明的事件方法。具体调停者知晓所有的具体同事类，并负责具体的协调个同事对象的交互关系；
- 抽象同事类(Colleague)角色：定义出调停者到同事对象的接口。同事对象只知道调停者而不知道其余的同事对象；
- 具体同事类(ConcreteColleague)角色：所有的具体同事类均从抽象同事类继承而来。实现自己的业务，在需要与其他同事通信的时候，就与持有的调停者通信，调停者会负责与其他的同事交互。

#### 源代码


#### 实例


#### 分析
##### 优点
- 松散耦合  
    调停者模式通过把多个同事对象之间的交互封装到调停    者对象里面，从而使得同事对象之间松散耦合，基本上    可以做到互补依赖。这样一来，同事对象就可以独立地    变化和复用，而不再像以前那样“牵一处而动全身”了。

- 集中控制交互  
    多个同事对象的交互，被封装在调停者对象里面集中管    理，使得这些交互行为发生变化的时候，只需要修改调    停者对象就可以了，当然如果是已经做好的系统，那么    就扩展调停者对象，而各个同事类不需要做修改。

- 多对多变成一对多  
    没有使用调停者模式的时候，同事对象之间的关系通常    是多对多的，引入调停者对象以后，调停者对象和同事    对象的关系通常变成双向的一对多，这会让对象的关系    更容易理解和实现。

##### 缺点
&emsp;&emsp;调停者模式的一个潜在缺点是，过度集中化。如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到调停者的时候，会导致调停者对象变得十分复杂，而且难于管理和维护