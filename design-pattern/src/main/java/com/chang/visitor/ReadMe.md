#### 概述
&emsp;&emsp;访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某中数据结构元素之上的操作。一旦这些操作需要修改的话，接收这个操作的数据结构则可以保持不变。

#### 分派的概念
&emsp;&emsp;变量被声明的类型叫做变量的静态类型(Static Type);而变量索引用对象的真实类型又叫做变量的实际类型(Actual Type).**比较直观的理解就是用接口声明的变量，而用类的实例初始化**，例如：
```
List<String> list = null;
list = new ArrayList<String>();
//list的静态类型(明显类型)是List, 而list的实际类型是ArrayList.
```
&emsp;&emsp; 根据对象的类型而对方法进行的选择，就是**分派(Dispatch)**，分派又分为两种，即静态分派和动态分派。
- 静态分派(Static Dispatch)  
    发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。
- 动态分派(Dynamic Dispatch)  
    发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派.

&emsp;&emsp; 问题的核心: Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型.

#### 分派的类型
&emsp;&emsp; 一个方法所属的对象叫做方法的接收者，方法的接收者与方法的参数统称做方法的宗量.    
&emsp;&emsp;根据分派可以基于多少种宗量，可以将面向对象的语言划分为单分派语言(Uni-Dispatch)和多分派语言(Multi-Dispatch)。单分派语言根据一个宗量的类型进行对方法的选择，多分派语言根据多于一个的宗量的类型对方法进行选择.    
&emsp;&emsp;Java就是**动态的单分派语言**，因为这种语言的动态分派仅仅会考虑到方法的接收者的类型，同时又是**静态的多分派语言**，因为这种语言对重载方法的分派会考虑到方法的接收者的类型以及方法的所有参数的类型

#### 双重分派
&emsp;&emsp; 一个方法根据两个宗量的类型来决定执行不同的代码，这就是“双重分派”。Java语言不支持动态的多分派，也就意味着Java不支持动态的双分派。但是通过使用设计模式，也可以在Java语言里实现动态的双重分派。

#### 访问者模式


##### 优点
- 好的扩展性  
&emsp;&emsp;能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。  
- 好的复用性  
&emsp;&emsp;可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。
- 分离无关行为  
&emsp;&emsp;可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。

##### 缺点
- 对象结构变化很困难    
&emsp;&emsp;不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。
- 破坏封装    
&emsp;&emsp;访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。