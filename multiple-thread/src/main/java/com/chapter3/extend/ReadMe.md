#### description    
example in this package:  
&emsp;&emsp; 多线程中存在一些其他的需求，例如多线程都到某个状态后才会触发的状态等，本包中就是用于解决这样的问题。
	 
*** 
##### CountDownLatch
&emsp;&emsp; 提供的机制是当多个(具体数值等于初始化CountDownLatch时的count参数的值)线程都到达了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件来触发自己后续的工作，**等待的线程可以是多个**，即CountDownLatch是可以唤醒多个等待的线程。      
&emsp;&emsp; 如果CountDownLatch初始化的count值为1，则退化为单一事件了，类似wait和notifyAll.    
CountDownLatchTest.java执行结果：
```
0-th wait...
1-th wait...
2-th wait...
0-th of go...
1-th of go...
```
**分析**    
&emsp;&emsp; countDownLatch的count数量的线程全部都到达之后， go线程才会开始执行。
***
##### cyclicBarrier
&emsp;&emsp; 循环屏障，CyclicBarrier可以协同多个线程，让多个线程在这个屏障前等待，知道所有线程都到达了这个屏障时，再一起继续执行后面的动作。     
CyclicBarrierTest.java执行结果：
```
1-th wait...
4-th wait...
3-th wait...
0-th wait...
2-th wait...
2-th go...
3-th go...
4-th go...
1-th go...
0-th go...
```
**分析**    
&emsp;&emsp; CyclicBarrier的count数量的线程全部都到达之后，大家一起开始往下执行。     
**备注**    
&emsp;&emsp; 本例中线程池的线程如果小于count，则会发生死锁(线程池的所有线程都被占用了，且还在等待新的await，都不释放，就死锁了...)
***
##### Semaphore
&emsp;&emsp; 用于管理信号量的，构造的时候传入可供管理的信号量的数值，该数值就是控制并发的数量。我们需要控制并发的代码，执行前先获取信号(通过acquire获取信号许可)，执行后归还信号(通过release归还信号许可)。 acquire后semaphore可用的信号量就会减少一个，如果没有可用信号，acquire调用就会阻塞。release之后可用信号增加一个      
&emsp;&emsp; 如果semaphore管理的信号量为1个，就退化为互斥锁了；如果多余一个信号量，则主要用于控制并发数。      
&emsp;&emsp; 与通过控制线程数来控制并发数的方式相比，通过semaphore来控制并发数可以控制的更加细粒度，因为真正被控制最大并发的代码放在acquire和release之间就好了。     
SemaphoreTest.java执行结果：
```
1-th acquire...
3-th acquire...
0-th acquire...
0-th release...
1-th release...
3-th release...
10-th acquire...
2-th acquire...
7-th acquire...
7-th release...
2-th release...
13-th acquire...
14-th acquire...
10-th release...
15-th acquire...
14-th release...
16-th acquire...
15-th release...
17-th acquire...
```
**分析**    
&emsp;&emsp; 仔细分析上面结果，虽然线程池有10个线程，但同一个时刻，获取acquire的线程只有3个，仅有当一个线程release之后，其他的线程才能acquire。     
***
##### Exchanger
&emsp;&emsp; 用于在两个线程之间进行数据交换。线程会阻塞在Exchanger的exchange方法上，知道另外一个线程也到了同一个Exchanger的exchange方法时，二者进行交换，然后两个线程继续执行自身相关的代码。    
ExchangerTest.java执行结果：
```
thread2: before exchange
thread1: before exchange
thread2: after exchange
thread1: after exchange
[thread2.item1, thread2.item2]
[thread1.item1, thread1.item2]
```
&emsp;&emsp 线程1 sleep(1000),但线程2和线程1都在等待，几乎同一时间打印“after exchange”；    
***
##### Future和FutureTask
&emsp;&emsp; Future是一个接口，FutureTask是一个具体实现类。应用场景： 在使用类似于远程调用的时候，当调用的返回结果需要很长时间，并且与后续的部分代码无关，阻塞在这里的等待结果就会比较浪费时间。改进方法：调用函数后马上返回，然后继续向下执行，等需要用数据的时候再来用，或者说再来等待这个数据。具体实现起来有两种方式：1. 用Future；2. 用回调。
ExchangerTest.java执行结果：
```
has invoke remote mehod, but i am still running...
time to wait for remote data...
get remote data...
{a=1, b=2, c=3}
```
**分析**    
&emsp;&emsp;
***




